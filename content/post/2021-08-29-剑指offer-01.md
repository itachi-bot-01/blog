---
title: "剑指offer Day-01"
categories: [ Technology ]
date: 2021-08-29T00:00:00+08:00
description: "熟刷剑指三百遍，不会coding也会编"
tags: [ LeetCode,算法,剑指offer]
url: /post/get-offer-01.html  
---




>  Every one is their God,if you give up on yourself,who else will save you?Every one is busy,some are busy livig,some are busy dying,and you, who are busy chasing fame and fortune,who are busy with daily necessities,try to stop to think a second:if your brain has been institutionalized?Where is your God?  
> 每个人都是自己的上帝，如果你自己都放弃自己了，还有谁会救你？每个人都在忙，有的忙着生，有的忙着死。忙着追逐名利的你、忙着柴米油盐的你，不妨停下来想一秒：你的大脑是不是已经被体制化了？你的上帝在哪里？
> 
>  -- -- 《肖申克的救赎》 

###  [9.用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

> 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
>
> 示例 1：
>
> ```shell
> 输入：  
> ["CQueue","appendTail","deleteHead","deleteHead"] 
> [[],[3],[],[]]  
> 输出：
> [null,null,3,-1]  
> ```
>
> 示例 2：  
>
> ```shell
> 输入：  
> ["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]  
> [[],[],[5],[2],[],[]]  
> 输出：
> [null,-1,null,null,5,2]  
> ```
>
> 提示：  
> 1 <= values <= 10000; 
>
> 最多会对 appendTail、deleteHead 进行 10000 次调用

##### 题解

```java
    /**
     * 思路:
     * 栈：先进后出，队列：先进后出
     * 1. 栈A正常插入，完事之后出栈插入到B栈中，这时候A的栈底元素在B中便是栈顶元素
     * 2. 队列出栈的时候直接从B栈pop，入栈的时候向A栈push
     * 3. 当B为空时需要从A把数据同步过来
     * 4. 当B为空，同时A也为空时，说明队列里面没有数据，直接返回-1
    */
class CQueue {
    Stack<Integer> headOperateStack;
    Stack<Integer> tailOperateStack;
    public CQueue() {
        headOperateStack = new Stack<Integer>();
        tailOperateStack = new Stack<Integer>();
    }
    public void appendTail(int value) {
        headOperateStack.push(value);
    }
    public int deleteHead() {
        if(!tailOperateStack.isEmpty()){
            return tailOperateStack.pop();
        }
        //考虑头为空和尾栈为空
        //1.队尾栈为空，队头栈也为空
        if(headOperateStack.isEmpty()){
            return -1;
        }
        //2.队尾栈为空，并且队头栈不为空
        while(!headOperateStack.isEmpty()){
            tailOperateStack.push(headOperateStack.pop());
        }
        return tailOperateStack.pop();
    }
}
```

##### 结果

```shell
执行用时：43 ms, 在所有 Java 提交中击败了78.67% 的用户
内存消耗：46.6 MB, 在所有 Java 提交中击败了58.49% 的用户
```

### [30.包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

> 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
>
> 示例:
>
> ```java
> MinStack minStack = new MinStack();
> minStack.push(-2);
> minStack.push(0);
> minStack.push(-3);
> minStack.min();   --> 返回 -3.
> minStack.pop();
> minStack.top();      --> 返回 0.
> minStack.min();   --> 返回 -2.
> ```
>
> 提示：
>  各函数的调用总次数不超过 20000 次

##### 题解

```java
class MinStack {
    Stack<Integer> A,B;
    public MinStack() {
        A = new Stack<>();//存放实际数据
        B = new Stack<>();//辅助存放min
    }
    /**
     *  push函数： 重点为保持栈B的元素是 非严格降序 的。
     *  1. 将 x 压入栈 A（即 A.push(x) ）；
     *  2. 若 栈B为空 或 x小于等于栈B的栈顶元素，则将x压入栈 B （即 B.push(x) ）
     *  始终保证B的栈顶元素是此时栈A的元素最小值
     */
    public void push(int val) {
        A.push(val);
        if(B.isEmpty() || B.peek()>=val){
            B.push(val);
        }
    }
    /**
     *   pop函数： 重点为保持栈 A,B 的元素一致性 。
     *   1. 执行栈 A 出栈（即 A.pop() ），将出栈元素记为 y 
     *   2. 若 y 等于栈 B 的栈顶元素，则执行栈 B 出栈（即 B.pop() ）
     */
    public void pop() {
        if(B.peek().equals(A.pop())){
            B.pop();
        }
    }
    public int top() {
        return A.peek();
    }
    public int min() {
        return B.peek();
    }
}
```

##### 结果

```shell
执行用时：17 ms, 在所有 Java 提交中击败了94.02% 的用户
内存消耗：40.4 MB, 在所有 Java 提交中击败了31.12% 的用户
```

